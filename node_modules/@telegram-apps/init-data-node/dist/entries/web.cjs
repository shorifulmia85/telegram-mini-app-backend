"use strict";
Object.defineProperty(exports, Symbol.toStringTag, { value: "Module" });
const shared = require("./shared-tVOPR7Iy.cjs");
const createHmac = async (data, key) => {
  const encoder = new TextEncoder();
  return crypto.subtle.sign(
    "HMAC",
    await crypto.subtle.importKey(
      "raw",
      typeof key === "string" ? encoder.encode(key) : key,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign", "verify"]
    ),
    typeof data === "string" ? encoder.encode(data) : data
  );
};
function hashToken(token) {
  return shared.hashToken(token, createHmac);
}
function isValid(value, token, options) {
  return shared.isValid(value, token, validate, options);
}
function sign(data, key, authDate, options) {
  return shared.sign(data, key, authDate, signData, options);
}
function signData(data, key, options) {
  return shared.signData(data, key, createHmac, options);
}
function validate(value, token, options) {
  return Promise.resolve().then(() => shared.validate(value, token, signData, options));
}
exports.AuthDateInvalidError = shared.AuthDateInvalidError;
exports.ExpiredError = shared.ExpiredError;
exports.SignatureInvalidError = shared.SignatureInvalidError;
exports.SignatureMissingError = shared.SignatureMissingError;
exports.isAuthDateInvalidError = shared.isAuthDateInvalidError;
exports.isExpiredError = shared.isExpiredError;
exports.isSignatureInvalidError = shared.isSignatureInvalidError;
exports.isSignatureMissingError = shared.isSignatureMissingError;
exports.isValid3rd = shared.isValid3rd;
exports.parse = shared.parse;
exports.validate3rd = shared.validate3rd;
exports.hashToken = hashToken;
exports.isValid = isValid;
exports.sign = sign;
exports.signData = signData;
exports.validate = validate;
//# sourceMappingURL=web.cjs.map
