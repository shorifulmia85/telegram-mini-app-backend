"use strict";
const transformers = require("@telegram-apps/transformers");
const errorKid = require("error-kid");
function hashToken(token, createHmac) {
  return createHmac(token, "WebAppData");
}
function sign(data, key, authDate, signData2, options) {
  const searchParams = new URLSearchParams(
    transformers.serializeInitDataQuery({
      ...data,
      auth_date: authDate,
      hash: "",
      signature: data.signature || ""
    })
  );
  searchParams.delete("hash");
  const pairs = [...searchParams.entries()].map(([name, value]) => `${name}=${value}`).sort();
  function processSign2(s) {
    searchParams.append("hash", s);
    return searchParams.toString();
  }
  const sign2 = signData2(pairs.join("\n"), key, options);
  return typeof sign2 === "string" ? processSign2(sign2) : sign2.then(processSign2);
}
function arrayBufferToHex(buffer) {
  return new Uint8Array(buffer).reduce((acc, byte) => {
    return acc + byte.toString(16).padStart(2, "0");
  }, "");
}
function hexToArrayBuffer(hexString) {
  if (hexString.length % 2 !== 0) {
    throw new Error("Hex string must have an even number of characters");
  }
  const buffer = new ArrayBuffer(hexString.length / 2);
  const uint8Array = new Uint8Array(buffer);
  for (let i = 0; i < hexString.length; i += 2) {
    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);
  }
  return buffer;
}
function signData(data, key, createHmac, options = {}) {
  const keyHmac = options.tokenHashed ? typeof key === "string" ? hexToArrayBuffer(key) : key : hashToken(key, createHmac);
  if (keyHmac instanceof Promise) {
    return keyHmac.then((v) => createHmac(data, v)).then(arrayBufferToHex);
  }
  const hmac = createHmac(data, keyHmac);
  return hmac instanceof Promise ? hmac.then(arrayBufferToHex) : arrayBufferToHex(hmac);
}
const [
  AuthDateInvalidError,
  isAuthDateInvalidError
] = errorKid.errorClassWithData(
  "AuthDateInvalidError",
  (value) => ({ value }),
  (value) => [`"auth_date" is invalid: ${value || "value is missing"}`]
);
const [
  SignatureInvalidError,
  isSignatureInvalidError
] = errorKid.errorClass("SignatureInvalidError");
const [
  SignatureMissingError,
  isSignatureMissingError
] = errorKid.errorClass("SignatureMissingError", (thirdParty) => [
  `"${thirdParty ? "signature" : "hash"}" parameter is missing`
]);
const [
  ExpiredError,
  isExpiredError
] = errorKid.errorClassWithData(
  "ExpiredError",
  (issuedAt, expiresAt) => ({ issuedAt, expiresAt }),
  (issuedAt, expiresAt, now) => [
    `Init data expired. Issued at ${issuedAt.toISOString()}, expires at ${expiresAt.toISOString()}, now is ${now.toISOString()}`
  ]
);
function processSign(actual, expected) {
  if (actual !== expected) {
    throw new SignatureInvalidError();
  }
  return;
}
function validate(value, token, signData2, options = {}) {
  let authDate;
  let authDateString;
  let hash;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      hash = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!hash) {
    throw new SignatureMissingError(false);
  }
  if (!authDate) {
    throw new AuthDateInvalidError(authDateString);
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      throw new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs));
    }
  }
  pairs.sort();
  const sign2 = signData2(pairs.join("\n"), token, options);
  return typeof sign2 === "string" ? processSign(sign2, hash) : sign2.then((v) => processSign(v, hash));
}
function isValid(value, token, validate2, options) {
  try {
    const maybePromise = validate2(value, token, options);
    return maybePromise ? maybePromise.then(() => true, () => false) : true;
  } catch {
    return false;
  }
}
function processResult(verified) {
  if (!verified) {
    throw new SignatureInvalidError();
  }
  return;
}
function validate3rd$1(value, botId, verify, options = {}) {
  let authDate;
  let authDateString;
  let signature;
  const pairs = [];
  (typeof value === "string" ? new URLSearchParams(value) : value).forEach((value2, key) => {
    if (key === "hash") {
      return;
    }
    if (key === "signature") {
      signature = value2;
      return;
    }
    if (key === "auth_date") {
      authDateString = value2;
      const authDateNum = parseInt(value2, 10);
      if (!Number.isNaN(authDateNum)) {
        authDate = new Date(authDateNum * 1e3);
      }
    }
    pairs.push(`${key}=${value2}`);
  });
  if (!signature) {
    throw new SignatureMissingError(true);
  }
  if (!authDate) {
    throw new AuthDateInvalidError(authDateString);
  }
  const { expiresIn = 86400 } = options;
  if (expiresIn > 0) {
    const expiresAtTs = authDate.getTime() + expiresIn * 1e3;
    const nowTs = Date.now();
    if (expiresAtTs < nowTs) {
      throw new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs));
    }
  }
  const verified = verify(
    `${botId}:WebAppData
${pairs.sort().join("\n")}`,
    options.test ? "40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec" : "e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d",
    signature
  );
  return typeof verified === "boolean" ? processResult(verified) : verified.then(processResult);
}
function isValid3rd$1(value, botId, validate2, options) {
  try {
    const maybePromise = validate2(value, botId, options);
    return maybePromise ? maybePromise.then(() => true, () => false) : true;
  } catch {
    return false;
  }
}
const parse = transformers.parseInitDataQuery;
const verify3rd = async (data, key, signature) => {
  return crypto.subtle.verify(
    "Ed25519",
    await crypto.subtle.importKey("raw", Buffer.from(key, "hex"), "Ed25519", false, ["verify"]),
    Buffer.from(signature, "base64"),
    Buffer.from(data)
  );
};
async function validate3rd(value, botId, options) {
  return validate3rd$1(value, botId, verify3rd, options);
}
function isValid3rd(value, botId, options) {
  return isValid3rd$1(value, botId, validate3rd, options);
}
exports.AuthDateInvalidError = AuthDateInvalidError;
exports.ExpiredError = ExpiredError;
exports.SignatureInvalidError = SignatureInvalidError;
exports.SignatureMissingError = SignatureMissingError;
exports.hashToken = hashToken;
exports.isAuthDateInvalidError = isAuthDateInvalidError;
exports.isExpiredError = isExpiredError;
exports.isSignatureInvalidError = isSignatureInvalidError;
exports.isSignatureMissingError = isSignatureMissingError;
exports.isValid = isValid;
exports.isValid3rd = isValid3rd;
exports.parse = parse;
exports.sign = sign;
exports.signData = signData;
exports.validate = validate;
exports.validate3rd = validate3rd;
//# sourceMappingURL=shared-tVOPR7Iy.cjs.map
