{"version":3,"file":"shared-aDQj8NQw.js","sources":["../../src/hashToken.ts","../../src/sign.ts","../../src/converters/arrayBufferToHex.ts","../../src/converters/hexToArrayBuffer.ts","../../src/signData.ts","../../src/errors.ts","../../src/validate.ts","../../src/isValid.ts","../../src/validate3rd.ts","../../src/isValid3rd.ts","../../src/parse.ts","../../src/entries/shared.ts"],"sourcesContent":["import type { CreateHmacFn, Text } from './types.js';\n\nexport function hashToken<H extends CreateHmacFn<any>>(token: Text, createHmac: H): ReturnType<H> {\n  return createHmac(token, 'WebAppData') as ReturnType<H>;\n}\n","import { serializeInitDataQuery } from '@telegram-apps/transformers';\n\nimport type { SharedOptions, SignData, SignDataAsyncFn, SignDataSyncFn, Text } from './types.js';\n\nexport type SignOptions = SharedOptions;\n\n/**\n * Signs specified init data.\n * @param data - init data to sign.\n * @param authDate - date, when this init data should be signed.\n * @param key - private key.\n * @param signData - function signing data.\n * @param options - additional options.\n * @returns Signed init data presented as query parameters.\n */\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataSyncFn,\n  options?: SignOptions,\n): string;\n\n/**\n * Signs specified init data.\n * @param data - init data to sign.\n * @param authDate - date, when this init data should be signed.\n * @param key - private key.\n * @param signData - function signing data.\n * @param options - additional options.\n * @returns Signed init data presented as query parameters.\n */\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataAsyncFn,\n  options?: SignOptions,\n): Promise<string>;\n\nexport function sign(\n  data: SignData,\n  key: Text,\n  authDate: Date,\n  signData: SignDataSyncFn | SignDataAsyncFn,\n  options?: SignOptions,\n): string | Promise<string> {\n  // Create search parameters, which will be signed further.\n  const searchParams = new URLSearchParams(\n    serializeInitDataQuery({\n      ...data,\n      auth_date: authDate,\n      hash: '',\n      signature: data.signature || '',\n    }),\n  );\n  searchParams.delete('hash');\n\n  // Convert search params to pairs and sort the final array.\n  const pairs = [...searchParams.entries()]\n    .map(([name, value]) => `${name}=${value}`)\n    .sort();\n\n  // Compute sign, append it to the params and return.\n  function processSign(s: string): string {\n    searchParams.append('hash', s);\n    return searchParams.toString();\n  }\n\n  const sign = signData(pairs.join('\\n'), key, options);\n  return typeof sign === 'string' ? processSign(sign) : sign.then(processSign);\n}\n","/**\n * Converts array buffer to hex.\n * @param buffer - buffer to convert\n */\nexport function arrayBufferToHex(buffer: ArrayBuffer): string {\n  return new Uint8Array(buffer).reduce((acc, byte) => {\n    // Convert byte to hex and pad with zero if needed (e.g., \"0a\" instead of \"a\")\n    return acc + byte.toString(16).padStart(2, '0');\n  }, '');\n}\n","/**\n * Converts a hex string to ArrayBuffer.\n * @param hexString - value to convert.\n */\nexport function hexToArrayBuffer(hexString: string): ArrayBuffer {\n  if (hexString.length % 2 !== 0) {\n    throw new Error('Hex string must have an even number of characters');\n  }\n\n  const buffer = new ArrayBuffer(hexString.length / 2);\n  const uint8Array = new Uint8Array(buffer);\n  for (let i = 0; i < hexString.length; i += 2) {\n    uint8Array[i / 2] = parseInt(hexString.substring(i, i + 2), 16);\n  }\n\n  return buffer;\n}","import { hashToken } from './hashToken.js';\nimport { arrayBufferToHex } from './converters/arrayBufferToHex.js';\nimport { hexToArrayBuffer } from './converters/hexToArrayBuffer.js';\nimport type { CreateHmacFn, SharedOptions, Text } from './types.js';\n\nexport type SignDataOptions = SharedOptions;\n\n/**\n * Signs specified data with the passed token.\n * @param data - data to sign.\n * @param key - private key.\n * @param createHmac - function to create HMAC-SHA256.\n * @param options - additional method options.\n * @returns Data sign.\n */\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<false>,\n  options?: SignDataOptions,\n): string;\n\n/**\n * Signs specified data with the passed token.\n * @param data - data to sign.\n * @param key - private key.\n * @param createHmac - function to create HMAC-SHA256.\n * @param options - additional method options.\n * @returns Data sign.\n */\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<true>,\n  options?: SignDataOptions,\n): Promise<string>;\n\nexport function signData(\n  data: Text,\n  key: Text,\n  createHmac: CreateHmacFn<boolean>,\n  options: SignDataOptions = {},\n): string | Promise<string> {\n  const keyHmac = options.tokenHashed\n    ? typeof key === 'string'\n      // If a hashed token was passed, we assume that it is a HEX string. Not to mess with\n      // the createHmac function, we should convert this HEX string to ArrayBuffer. Otherwise,\n      // incorrect behavior will be met.\n      ? hexToArrayBuffer(key)\n      : key\n    : hashToken(key, createHmac);\n\n  if (keyHmac instanceof Promise) {\n    return keyHmac.then(v => createHmac(data, v)).then(arrayBufferToHex);\n  }\n\n  const hmac = createHmac(data, keyHmac);\n  return hmac instanceof Promise ? hmac.then(arrayBufferToHex) : arrayBufferToHex(hmac);\n}\n","import { errorClass, errorClassWithData } from 'error-kid';\n\nexport const [\n  AuthDateInvalidError,\n  isAuthDateInvalidError,\n] = errorClassWithData<{ value: string | undefined }, [value?: string]>(\n  'AuthDateInvalidError',\n  value => ({ value }),\n  value => [`\"auth_date\" is invalid: ${value || 'value is missing'}`],\n);\n\nexport const [\n  SignatureInvalidError,\n  isSignatureInvalidError,\n] = errorClass('SignatureInvalidError');\n\nexport const [\n  SignatureMissingError,\n  isSignatureMissingError,\n] = errorClass<[thirdParty: boolean]>('SignatureMissingError', (thirdParty) => [\n  `\"${thirdParty ? 'signature' : 'hash'}\" parameter is missing`,\n]);\n\nexport const [\n  ExpiredError,\n  isExpiredError,\n] = errorClassWithData<\n  { issuedAt: Date; expiresAt: Date },\n  [issuedAt: Date, expiresAt: Date, now: Date]\n>(\n  'ExpiredError',\n  (issuedAt, expiresAt) => ({ issuedAt, expiresAt }),\n  (issuedAt, expiresAt, now) => [\n    `Init data expired. Issued at ${issuedAt.toISOString()}, expires at ${expiresAt.toISOString()}, now is ${now.toISOString()}`,\n  ],\n);","import type { SharedOptions, SignDataAsyncFn, SignDataSyncFn, Text } from './types.js';\nimport {\n  AuthDateInvalidError,\n  ExpiredError,\n  SignatureMissingError,\n  SignatureInvalidError,\n} from './errors.js';\n\nexport interface ValidateOptions extends SharedOptions {\n  /**\n   * Time in seconds which states, how long from creation time init data is considered valid.\n   *\n   * In other words, in case when authDate + expiresIn is before current time, init data is\n   * recognized as expired.\n   *\n   * In case this value is equal to 0, the function does not check init data expiration.\n   * @default 86400 (1 day)\n   */\n  expiresIn?: number;\n}\n\nexport type ValidateValue = string | URLSearchParams;\n\nfunction processSign(actual: string, expected: string): void | never {\n  if (actual !== expected) {\n    throw new SignatureInvalidError();\n  }\n  return;\n}\n\n/**\n * Validates passed init data.\n * @param value - value to check.\n * @param token - bot secret token.\n * @param signData - function signing data.\n * @param options - additional validation options.\n * @throws {SignatureInvalidError} Signature is invalid.\n * @throws {AuthDateInvalidError} \"auth_date\" property is missing or invalid.\n * @throws {SignatureMissingError} \"hash\" property is missing.\n * @throws {ExpiredError} Init data is expired.\n */\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataSyncFn,\n  options?: ValidateOptions,\n): void | never;\n\n/**\n * Validates passed init data.\n * @param value - value to check.\n * @param token - bot secret token.\n * @param signData - function signing data.\n * @param options - additional validation options.\n * @throws {SignatureInvalidError} Signature is invalid.\n * @throws {AuthDateInvalidError} \"auth_date\" property is missing or invalid.\n * @throws {SignatureMissingError} \"hash\" property is missing.\n * @throws {ExpiredError} Init data is expired.\n */\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataAsyncFn,\n  options?: ValidateOptions,\n): Promise<void>;\n\nexport function validate(\n  value: ValidateValue,\n  token: Text,\n  signData: SignDataSyncFn | SignDataAsyncFn,\n  options: ValidateOptions = {},\n): void | never | Promise<void> {\n  // Init data required params.\n  let authDate: Date | undefined;\n  let authDateString: string | undefined;\n  let hash: string | undefined;\n\n  // All search params pairs presented as `k=v`.\n  const pairs: string[] = [];\n\n  // Iterate over all key-value pairs of parsed parameters and find required\n  // parameters.\n  (typeof value === 'string' ? new URLSearchParams(value) : value).forEach((value, key) => {\n    if (key === 'hash') {\n      hash = value;\n      return;\n    }\n\n    if (key === 'auth_date') {\n      authDateString = value;\n      const authDateNum = parseInt(value, 10);\n      if (!Number.isNaN(authDateNum)) {\n        authDate = new Date(authDateNum * 1000);\n      }\n    }\n\n    pairs.push(`${key}=${value}`);\n  });\n\n  // Hash and auth date always required.\n  if (!hash) {\n    throw new SignatureMissingError(false);\n  }\n\n  if (!authDate) {\n    throw new AuthDateInvalidError(authDateString);\n  }\n\n  // In case, expiration time passed, we do additional parameters check.\n  const { expiresIn = 86400 } = options;\n  if (expiresIn > 0) {\n    // Check if init data expired.\n    const expiresAtTs = authDate.getTime() + expiresIn * 1000;\n    const nowTs = Date.now();\n    if (expiresAtTs < nowTs) {\n      throw new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs));\n    }\n  }\n\n  // According to docs, we sort all the pairs in alphabetical order.\n  pairs.sort();\n\n  const sign = signData(pairs.join('\\n'), token, options);\n\n  return typeof sign === 'string'\n    ? processSign(sign, hash)\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n    : sign.then(v => processSign(v, hash!));\n}\n","import type { Text } from './types.js';\nimport type { ValidateOptions, ValidateValue } from './validate.js';\n\ntype ValidateSyncFn = (\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateOptions,\n) => void | never;\n\ntype ValidateAsyncFn = (\n  value: ValidateValue,\n  token: Text,\n  options?: ValidateOptions,\n) => Promise<void>;\n\n/**\n * @param value - value to check.\n * @param token - bot secret token.\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is valid.\n */\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateSyncFn,\n  options?: ValidateOptions,\n): boolean;\n\n/**\n * @param value - value to check.\n * @param token - bot secret token.\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is valid.\n */\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateAsyncFn,\n  options?: ValidateOptions,\n): Promise<boolean>;\n\nexport function isValid(\n  value: ValidateValue,\n  token: Text,\n  validate: ValidateSyncFn | ValidateAsyncFn,\n  options?: ValidateOptions,\n): boolean | Promise<boolean> {\n  try {\n    const maybePromise = validate(value, token, options);\n    return maybePromise\n      ? maybePromise.then(() => true, () => false)\n      : true;\n  } catch {\n    return false;\n  }\n}\n","import type { Verify3rdFn } from './types.js';\nimport {\n  AuthDateInvalidError,\n  ExpiredError,\n  SignatureInvalidError,\n  SignatureMissingError,\n} from './errors.js';\n\nexport interface Validate3rdOptions {\n  /**\n   * Time in seconds which states, how long from creation time init data is considered valid.\n   *\n   * In other words, in case when authDate + expiresIn is before current time, init data is\n   * recognized as expired.\n   *\n   * In case this value is equal to 0, the function does not check init data expiration.\n   * @default 86400 (1 day)\n   */\n  expiresIn?: number;\n  /**\n   * When true, uses the test environment public key to validate init data.\n   * @default false\n   */\n  test?: boolean;\n}\n\nexport type Validate3rdValue = string | URLSearchParams;\n\nfunction processResult(verified: boolean): void | never {\n  if (!verified) {\n    throw new SignatureInvalidError();\n  }\n  return;\n}\n\n/**\n * Validates passed init data using a publicly known Ee25519 key.\n * @param value - value to check.\n * @param botId - bot identifier\n * @param verify - function to verify sign\n * @param options - additional validation options.\n * @throws {SignatureInvalidError} Signature is invalid.\n * @throws {AuthDateInvalidError} \"auth_date\" property is missing or invalid.\n * @throws {SignatureMissingError} \"hash\" property is missing.\n * @throws {ExpiredError} Init data is expired.\n */\nexport function validate3rd(\n  value: Validate3rdValue,\n  botId: number,\n  verify: Verify3rdFn<false>,\n  options?: Validate3rdOptions,\n): void | never;\n\n/**\n * Validates passed init data using a publicly known Ee25519 key.\n * @param value - value to check.\n * @param botId - bot identifier\n * @param verify - function to verify sign\n * @param options - additional validation options.\n * @throws {SignatureInvalidError} Signature is invalid.\n * @throws {AuthDateInvalidError} \"auth_date\" property is missing or invalid.\n * @throws {SignatureMissingError} \"hash\" property is missing.\n * @throws {ExpiredError} Init data is expired.\n */\nexport function validate3rd(\n  value: Validate3rdValue,\n  botId: number,\n  verify: Verify3rdFn<true>,\n  options?: Validate3rdOptions,\n): Promise<void>;\n\nexport function validate3rd(\n  value: Validate3rdValue,\n  botId: number,\n  verify: Verify3rdFn<boolean>,\n  options: Validate3rdOptions = {},\n): void | never | Promise<void> {\n  // Init data required params.\n  let authDate: Date | undefined;\n  let authDateString: string | undefined;\n  let signature: string | undefined;\n\n  // All search params pairs presented as `k=v`.\n  const pairs: string[] = [];\n\n  // Iterate over all key-value pairs of parsed parameters and find required\n  // parameters.\n  (typeof value === 'string' ? new URLSearchParams(value) : value).forEach((value, key) => {\n    if (key === 'hash') {\n      return;\n    }\n\n    if (key === 'signature') {\n      signature = value;\n      return;\n    }\n\n    if (key === 'auth_date') {\n      authDateString = value;\n      const authDateNum = parseInt(value, 10);\n      if (!Number.isNaN(authDateNum)) {\n        authDate = new Date(authDateNum * 1000);\n      }\n    }\n\n    pairs.push(`${key}=${value}`);\n  });\n\n  // Signature and auth date always required.\n  if (!signature) {\n    throw new SignatureMissingError(true);\n  }\n\n  if (!authDate) {\n    throw new AuthDateInvalidError(authDateString);\n  }\n\n  // In case, expiration time passed, we do additional parameters check.\n  const { expiresIn = 86400 } = options;\n  if (expiresIn > 0) {\n    // Check if init data expired.\n    const expiresAtTs = authDate.getTime() + expiresIn * 1000;\n    const nowTs = Date.now();\n    if (expiresAtTs < nowTs) {\n      throw new ExpiredError(authDate, new Date(expiresAtTs), new Date(nowTs));\n    }\n  }\n\n  const verified = verify(\n    `${botId}:WebAppData\\n${pairs.sort().join('\\n')}`,\n    options.test\n      ? '40055058a4ee38156a06562e52eece92a771bcd8346a8c4615cb7376eddf72ec'\n      : 'e7bf03a2fa4602af4580703d88dda5bb59f32ed8b02a56c187fe7d34caed242d',\n    signature,\n  );\n\n  return typeof verified === 'boolean' ? processResult(verified) : verified.then(processResult);\n}\n","import type { Validate3rdOptions, Validate3rdValue } from './validate3rd.js';\n\ntype ValidateSyncFn = (\n  value: Validate3rdValue,\n  botId: number,\n  options?: Validate3rdOptions,\n) => void | never;\n\ntype ValidateAsyncFn = (\n  value: Validate3rdValue,\n  botId: number,\n  options?: Validate3rdOptions,\n) => Promise<void>;\n\n/**\n * @param value - value to check.\n * @param botId - bot identifier\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is signed by Telegram.\n */\nexport function isValid3rd(\n  value: Validate3rdValue,\n  botId: number,\n  validate: ValidateAsyncFn,\n  options?: Validate3rdOptions,\n): Promise<boolean>;\n\n/**\n * @param value - value to check.\n * @param botId - bot identifier\n * @param validate - function validating the init data.\n * @param options - additional validation options.\n * @returns True is specified init data is signed by Telegram.\n */\nexport function isValid3rd(\n  value: Validate3rdValue,\n  botId: number,\n  validate: ValidateSyncFn,\n  options?: Validate3rdOptions,\n): boolean;\n\nexport function isValid3rd(\n  value: Validate3rdValue,\n  botId: number,\n  validate: ValidateSyncFn | ValidateAsyncFn,\n  options?: Validate3rdOptions,\n): boolean | Promise<boolean> {\n  try {\n    const maybePromise = validate(value, botId, options);\n    return maybePromise\n      ? maybePromise.then(() => true, () => false)\n      : true;\n  } catch {\n    return false;\n  }\n}\n","import { parseInitDataQuery } from '@telegram-apps/transformers';\n\n/**\n * Parses an incoming value as init data.\n */\nexport const parse = parseInitDataQuery;\n","import {\n  validate3rd as _validate3rd,\n  type Validate3rdValue,\n  type Validate3rdOptions,\n} from '../validate3rd.js';\nimport { isValid3rd as _isValid3rd } from '../isValid3rd.js';\nimport type { Verify3rdFn } from '../types.js';\n\nexport type { Chat, ChatType, InitData, User } from '@telegram-apps/types';\n\nexport { parse } from '../parse.js';\nexport type { ValidateOptions, ValidateValue } from '../validate.js';\nexport type { SignData, Text, CreateHmacFn } from '../types.js';\nexport {\n  SignatureMissingError,\n  SignatureInvalidError,\n  ExpiredError,\n  AuthDateInvalidError,\n  isSignatureMissingError,\n  isAuthDateInvalidError,\n  isExpiredError,\n  isSignatureInvalidError,\n} from '../errors.js';\n\nexport type { Validate3rdValue, Validate3rdOptions, Verify3rdFn };\n\nconst verify3rd: Verify3rdFn<true> = async (data, key, signature) => {\n  return crypto.subtle.verify(\n    'Ed25519',\n    await crypto\n      .subtle\n      .importKey('raw', Buffer.from(key, 'hex'), 'Ed25519', false, ['verify']),\n    Buffer.from(signature, 'base64'),\n    Buffer.from(data),\n  );\n};\n\n/**\n * Validates passed init data using a publicly known Ee25519 key.\n * @param value - value to check.\n * @param botId - bot identifier\n * @param options - additional validation options.\n * @throws {SignatureInvalidError} Signature is invalid.\n * @throws {AuthDateInvalidError} \"auth_date\" property is missing or invalid.\n * @throws {SignatureMissingError} \"hash\" property is missing.\n * @throws {ExpiredError} Init data is expired.\n */\nexport async function validate3rd(\n  value: Validate3rdValue,\n  botId: number,\n  options?: Validate3rdOptions,\n): Promise<void> {\n  return _validate3rd(value, botId, verify3rd, options);\n}\n\n/**\n * @param value - value to check.\n * @param botId - bot identifier\n * @param options - additional validation options.\n * @returns True is specified init data is signed by Telegram.\n */\nexport function isValid3rd(\n  value: Validate3rdValue,\n  botId: number,\n  options?: Validate3rdOptions,\n): Promise<boolean> {\n  return _isValid3rd(value, botId, validate3rd, options);\n}"],"names":["signData","processSign","sign","value","validate","validate3rd","isValid3rd","_validate3rd","_isValid3rd"],"mappings":"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"}